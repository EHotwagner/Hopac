<!doctype html>
<html>
<head>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/fsharp.min.js"></script>
<script>
$(document).ready(function() {
  $('code').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});
</script>
<title>Hopac.Experimental Library Reference</title>
<style>
p > code.hljs {
  display: inline;
  padding: 1px;
}
code {
  font-family: "Lucida Console", Monaco, monospace;
  font-size: 72%;
  border-radius: 3px;
}
span.h3 {
  display: inline-block;
  margin: 0.75em 0em 0.5em 0em;
}
span.spacing {
  display: inherit;
  margin: 0.5em 0em 0.5em 0em;
}
div.nested {
  padding-left: 1.5em;
}
a {
  text-decoration: none;
  font-weight: bold;
}
</style>
</head>
<body><table width="80%" align="center"><tr><td>
<h1>Hopac.Experimental Library Reference</h1>
<h2>Synopsis</h2>
<pre><code class="fsharp">namespace Hopac.Experimental
<span class="spacing">type <a id="dec:type Hopac.Experimental.Alts" href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt;
</span><span class="spacing">module <a id="dec:module Hopac.Experimental.Alts" href="#def:module%20Hopac.Experimental.Alts">Alts</a> =
  val consume: onNext: ('x -&gt; Job&lt;unit&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; Job&lt;unit&gt;
  val zero: unit -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt;
  val result: 'x -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt;
  val <a href="#def:val%20Hopac.Experimental.Alt.Discrete.merge">merge</a>: <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt;
  val bindJob: <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; ('x -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'y&gt;
  val bindFun: <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; ('x -&gt;     <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'y&gt; ) -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'y&gt;
  val processJob: onFirst:      ('x -&gt; Job&lt;'s * option&lt;'y&gt;&gt;)
               -&gt; onNext: ('s -&gt; 'x -&gt; Job&lt;'s * option&lt;'y&gt;&gt;)
               -&gt; Alts&lt;'x&gt;
               -&gt; Alts&lt;'y&gt;
  val scanJob: ('s -&gt; 'x -&gt; Job&lt;'s&gt;) -&gt; 's -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'s&gt;
  val scanFun: ('s -&gt; 'x -&gt;     's ) -&gt; 's -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'s&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.chooseJob">chooseJob</a>: ('x -&gt; Job&lt;option&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'y&gt;
  val <a href="#def:val%20Hopac.Experimental.Alt.Discrete.throttle">throttle</a>: timeOut: Alt&lt;unit&gt; -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.mapJob">mapJob</a>: ('x -&gt; Job&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'y&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.mapFun">mapFun</a>: ('x -&gt;     'y ) -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'y&gt;
  val noDups: <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; -&gt; <a href="#def:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt; when 'x : equality
</span><span class="spacing">module Alt =
<span class="spacing">  module <a id="dec:module Hopac.Experimental.Alt.Discrete" href="#def:module%20Hopac.Experimental.Alt.Discrete">Discrete</a> =
    val <a id="dec:val Hopac.Experimental.Alt.Discrete.merge" href="#def:val%20Hopac.Experimental.Alt.Discrete.merge">merge</a>: Alt&lt;'x&gt; -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'x&gt;
    val <a id="dec:val Hopac.Experimental.Alt.Discrete.switchMap" href="#def:val%20Hopac.Experimental.Alt.Discrete.switchMap">switchMap</a>: ('x -&gt; Alt&lt;'y&gt;) -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'y&gt;
    val <a id="dec:val Hopac.Experimental.Alt.Discrete.throttle" href="#def:val%20Hopac.Experimental.Alt.Discrete.throttle">throttle</a>: timeout: Alt&lt;_&gt; -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'x&gt;
    val <a id="dec:val Hopac.Experimental.Alt.Discrete.combineLatest" href="#def:val%20Hopac.Experimental.Alt.Discrete.combineLatest">combineLatest</a>: Alt&lt;'x&gt; -&gt; Alt&lt;'y&gt; -&gt; Alt&lt;'x * 'y&gt;
    val <a id="dec:val Hopac.Experimental.Alt.Discrete.choose" href="#def:val%20Hopac.Experimental.Alt.Discrete.choose">choose</a>: ('x -&gt; option&lt;'y&gt;) -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'y&gt;
    val <a id="dec:val Hopac.Experimental.Alt.Discrete.filter" href="#def:val%20Hopac.Experimental.Alt.Discrete.filter">filter</a>: ('x -&gt; bool) -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'x&gt;
    val <a id="dec:val Hopac.Experimental.Alt.Discrete.map" href="#def:val%20Hopac.Experimental.Alt.Discrete.map">map</a>: ('x -&gt; 'y) -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'y&gt;
</span></span><span class="spacing">type <a id="dec:type Hopac.Experimental.EagerSeq" href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;
</span><span class="spacing">module <a id="dec:module Hopac.Experimental.EagerSeq" href="#def:module%20Hopac.Experimental.EagerSeq">EagerSeq</a> =
<span class="spacing">  module <a id="dec:module Hopac.Experimental.EagerSeq.Now" href="#def:module%20Hopac.Experimental.EagerSeq.Now">Now</a> =
    val <a id="dec:val Hopac.Experimental.EagerSeq.Now.empty" href="#def:val%20Hopac.Experimental.EagerSeq.Now.empty">empty</a>: unit -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;
    val <a id="dec:val Hopac.Experimental.EagerSeq.Now.singleton" href="#def:val%20Hopac.Experimental.EagerSeq.Now.singleton">singleton</a>: 'x -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;
</span>  val <a id="dec:val Hopac.Experimental.EagerSeq.collectJob" href="#def:val%20Hopac.Experimental.EagerSeq.collectJob">collectJob</a>: ('x -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.chooseFun" href="#def:val%20Hopac.Experimental.EagerSeq.chooseFun">chooseFun</a>: ('x -&gt; option&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.chooseJob" href="#def:val%20Hopac.Experimental.EagerSeq.chooseJob">chooseJob</a>: ('x -&gt; Job&lt;option&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.filterFun" href="#def:val%20Hopac.Experimental.EagerSeq.filterFun">filterFun</a>: ('x -&gt; bool) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.generateFun" href="#def:val%20Hopac.Experimental.EagerSeq.generateFun">generateFun</a>: (unit -&gt; option&lt;'x&gt;) -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.generateJob" href="#def:val%20Hopac.Experimental.EagerSeq.generateJob">generateJob</a>: Job&lt;option&lt;'x&gt;&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.iterFun" href="#def:val%20Hopac.Experimental.EagerSeq.iterFun">iterFun</a>: ('x -&gt; unit) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;unit&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.iterJob" href="#def:val%20Hopac.Experimental.EagerSeq.iterJob">iterJob</a>: ('x -&gt; Job&lt;_&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;unit&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.mapFun" href="#def:val%20Hopac.Experimental.EagerSeq.mapFun">mapFun</a>: ('x -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.mapJob" href="#def:val%20Hopac.Experimental.EagerSeq.mapJob">mapJob</a>: ('x -&gt; Job&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.ofSeq" href="#def:val%20Hopac.Experimental.EagerSeq.ofSeq">ofSeq</a>: seq&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.toSeq" href="#def:val%20Hopac.Experimental.EagerSeq.toSeq">toSeq</a>: <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;ResizeArray&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.tryPickFun" href="#def:val%20Hopac.Experimental.EagerSeq.tryPickFun">tryPickFun</a>: ('x -&gt; option&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;option&lt;'y&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.unfoldFun" href="#def:val%20Hopac.Experimental.EagerSeq.unfoldFun">unfoldFun</a>: ('s -&gt; option&lt;'x * 's&gt;) -&gt; 's -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
  val <a id="dec:val Hopac.Experimental.EagerSeq.unfoldJob" href="#def:val%20Hopac.Experimental.EagerSeq.unfoldJob">unfoldJob</a>: ('s -&gt; Job&lt;option&lt;'x * 's&gt;&gt;) -&gt; 's -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
</span><span class="spacing">type Live = interface end
</span><span class="spacing">type Lazy = interface inherit Live end
</span><span class="spacing">module Stream =
<span class="spacing">  type Stream&lt;'l, 'x&gt; when 'l :&gt; Live = Stream of Hopac.Stream.Stream&lt;'x&gt;
</span><span class="spacing">  type Src&lt;'x&gt; = Hopac.Stream.Src&lt;'x&gt;
</span><span class="spacing">  module Src =
    val create: unit -&gt; Src&lt;'x&gt;
    val value: Src&lt;'x&gt; -&gt; 'x -&gt; Job&lt;unit&gt;
    val error: Src&lt;'x&gt; -&gt; exn -&gt; Job&lt;unit&gt;
    val close: Src&lt;'x&gt; -&gt; Job&lt;unit&gt;
    val tap: Src&lt;'x&gt; -&gt; Stream&lt;Live, 'x&gt;
</span><span class="spacing">  type Var&lt;'x&gt; = Hopac.Stream.Var&lt;'x&gt;
</span><span class="spacing">  module Var =
    val create: 'x -&gt; Var&lt;'x&gt;
    val get: Var&lt;'x&gt; -&gt; 'x
    val set: Var&lt;'x&gt; -&gt; 'x -&gt; Job&lt;unit&gt;
    val tap: Var&lt;'x&gt; -&gt; Stream&lt;Live, 'x&gt;
</span>  val nil&lt;'l, 'x when 'l :&gt; Live&gt; : Stream&lt;'l, 'x&gt;
  val cons: 'x -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val one: 'x -&gt; Stream&lt;'l, 'x&gt;
  val delay: (unit -&gt; Stream&lt;'l, 'x&gt;) -&gt; Stream&lt;'l, 'x&gt;
  val error: exn -&gt; Stream&lt;'l, 'x&gt;
  val never&lt;'l, 'x when 'l :&gt; Live&gt; : Stream&lt;'l, 'x&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.ofSeq">ofSeq</a>: seq&lt;'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val indefinitely: Job&lt;'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val once: Job&lt;'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.unfoldJob">unfoldJob</a>: ('s -&gt; #Job&lt;option&lt;'x * 's&gt;&gt;) -&gt; 's -&gt; Stream&lt;'l, 'x&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.unfoldFun">unfoldFun</a>: ('s -&gt; option&lt;'x * 's&gt;) -&gt; 's -&gt; Stream&lt;'l, 'x&gt;
  val generateFuns: 's -&gt; Hopac.Stream.GenerateFuns&lt;'s, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.generateFun">generateFun</a>: 's
                -&gt; ('s -&gt; bool)
                -&gt; ('s -&gt; 's)
                -&gt; ('s -&gt; 'x)
                -&gt; Stream&lt;'l, 'x&gt;
  val iterateJob: ('x -&gt; #Job&lt;'x&gt;) -&gt; 'x -&gt; Stream&lt;'l, 'x&gt;
  val iterateFun: ('x -&gt; 'x) -&gt; 'x -&gt; Stream&lt;'l, 'x&gt;
  val repeat: 'x -&gt; Stream&lt;'l, 'x&gt;
  val cycle: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val ofObservableOn: subscribeOn: SynchronizationContext
                   -&gt; IObservable&lt;'x&gt;
                   -&gt; Stream&lt;Live, 'x&gt;
  val ofObservableOnMain: IObservable&lt;'x&gt; -&gt; Stream&lt;Live, 'x&gt;
  val ofObservable: IObservable&lt;'x&gt; -&gt; Stream&lt;Live, 'x&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.chooseJob">chooseJob</a>: ('x -&gt; #Job&lt;option&lt;'y&gt;&gt;) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'y&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.chooseFun">chooseFun</a>: ('x -&gt; option&lt;'y&gt;) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'y&gt;
  val <a href="#def:val%20Hopac.Experimental.Alt.Discrete.choose">choose</a>: Stream&lt;'l, option&lt;'x&gt;&gt; -&gt; Stream&lt;'l, 'x&gt;
  val filterJob: ('x -&gt; #Job&lt;bool&gt;) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.filterFun">filterFun</a>: ('x -&gt; bool) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.mapJob">mapJob</a>: ('x -&gt; #Job&lt;'y&gt;) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'y&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.mapFun">mapFun</a>: ('x -&gt; 'y) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'y&gt;
  val mapConst: 'y -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'y&gt;
  val groupByJob: ('k -&gt; Job&lt;unit&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; #Job&lt;'y&gt;)
               -&gt; ('x -&gt; #Job&lt;'k&gt;)
               -&gt; Stream&lt;'l, 'x&gt;
               -&gt; Stream&lt;'l, 'y&gt; when 'k: equality
  val groupByFun: ('k -&gt; Job&lt;unit&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; 'y)
               -&gt; ('x -&gt; 'k)
               -&gt; Stream&lt;'l, 'x&gt;
               -&gt; Stream&lt;'l, 'y&gt; when 'k: equality
  val zip: Stream&lt;#Lazy, 'x     &gt;
        -&gt; Stream&lt;#Lazy,      'y&gt;
        -&gt; Stream&lt;'l, 'x * 'y&gt;
  val zipWithFun: ('x -&gt; 'y -&gt; 'z)
               -&gt; Stream&lt;#Lazy, 'x&gt;
               -&gt; Stream&lt;#Lazy, 'y&gt;
               -&gt; Stream&lt;'l, 'z&gt;
  val scanJob: ('s -&gt; 'x -&gt; #Job&lt;'s&gt;) -&gt; 's -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 's&gt;
  val scanFun: ('s -&gt; 'x -&gt; 's) -&gt; 's -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 's&gt;
  val scanFromJob: 's -&gt; ('s -&gt; 'x -&gt; #Job&lt;'s&gt;) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 's&gt;
  val scanFromFun: 's -&gt; ('s -&gt; 'x -&gt; 's) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 's&gt;
  val distinctByJob: ('x -&gt; #Job&lt;'k&gt;)
                  -&gt; Stream&lt;'l, 'x&gt;
                  -&gt; Stream&lt;'l, 'x&gt; when 'k: equality
  val distinctByFun: ('x -&gt; 'k)
                  -&gt; Stream&lt;'l, 'x&gt;
                  -&gt; Stream&lt;'l, 'x&gt; when 'k: equality
  val distinctUntilChangedWithJob: ('x -&gt; 'x -&gt; #Job&lt;bool&gt;)
                                -&gt; Stream&lt;'l, 'x&gt;
                                -&gt; Stream&lt;'l, 'x&gt;
  val distinctUntilChangedWithFun: ('x -&gt; 'x -&gt; bool)
                                -&gt; Stream&lt;'l, 'x&gt;
                                -&gt; Stream&lt;'l, 'x&gt;
  val distinctUntilChangedByJob: ('x -&gt; #Job&lt;'k&gt;)
                              -&gt; Stream&lt;'l, 'x&gt;
                              -&gt; Stream&lt;'l, 'x&gt; when 'k: equality
  val distinctUntilChangedByFun: ('x -&gt; 'k)
                              -&gt; Stream&lt;'l, 'x&gt;
                              -&gt; Stream&lt;'l, 'x&gt; when 'k: equality
  val distinctUntilChanged: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt; when 'x: equality
  val amb: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val <a href="#def:val%20Hopac.Experimental.Alt.Discrete.merge">merge</a>: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val append: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;#Lazy, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val switch: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val switchTo: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val ambAll: Stream&lt;'l, Stream&lt;'l, 'x&gt;&gt; -&gt; Stream&lt;'l, 'x&gt;
  val mergeAll: Stream&lt;'l, Stream&lt;'l, 'x&gt;&gt; -&gt; Stream&lt;'l, 'x&gt;
  val appendAll: Stream&lt;#Lazy, Stream&lt;#Lazy, 'x&gt;&gt; -&gt; Stream&lt;'l, 'x&gt;
  val switchAll: Stream&lt;'l, Stream&lt;'l, 'x&gt;&gt; -&gt; Stream&lt;'l, 'x&gt;
  val ambMap: ('x -&gt; Stream&lt;'l, 'y&gt;) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'y&gt;
  val mergeMap: ('x -&gt; Stream&lt;'l, 'y&gt;) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'y&gt;
  val appendMap: ('x -&gt; Stream&lt;#Lazy, 'y&gt;) -&gt; Stream&lt;#Lazy, 'x&gt; -&gt; Stream&lt;'ls, 'y&gt;
  val <a href="#def:val%20Hopac.Experimental.Alt.Discrete.switchMap">switchMap</a>: ('x -&gt; Stream&lt;'l, 'y&gt;) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'y&gt;
  val skip: int64 -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val take: int64 -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val skipUntil: Alt&lt;_&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val takeUntil: Alt&lt;_&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val takeAndSkipUntil: Alt&lt;_&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt; * Stream&lt;'l, 'x&gt;
  val skipWhileJob: ('x -&gt; #Job&lt;bool&gt;) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val skipWhileFun: ('x -&gt; bool) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val takeWhileJob: ('x -&gt; #Job&lt;bool&gt;) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val takeWhileFun: ('x -&gt; bool) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val catch: (exn -&gt; Stream&lt;'l, 'x&gt;) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val onCloseJob: Job&lt;unit&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val onCloseFun: (unit -&gt; unit) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val doFinalizeJob: Job&lt;unit&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val doFinalizeFun: (unit -&gt; unit) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val keepPrecedingFuns: Hopac.Stream.KeepPrecedingFuns&lt;'x, 'y&gt;
                      -&gt; Stream&lt;#Live, 'x&gt;
                      -&gt; Stream&lt;'l, 'y&gt;
  val keepPreceding: maxCount: int
                  -&gt; Stream&lt;#Live, 'x&gt;
                  -&gt; Stream&lt;'l, Queue&lt;'x&gt;&gt;
  val keepPreceding1: Stream&lt;#Live, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val keepFollowing1: Stream&lt;#Live, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val pullOn: ticks: Stream&lt;'l, _&gt; -&gt; Stream&lt;Lazy, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val debounce: timeout: Alt&lt;_&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val samplesBefore: ticks: Stream&lt;'l, _&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val samplesAfter: ticks: Stream&lt;'l, _&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val ignoreUntil: timeout: Job&lt;_&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val ignoreWhile: timeout: Job&lt;_&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val <a href="#def:val%20Hopac.Experimental.Alt.Discrete.combineLatest">combineLatest</a>: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'y&gt; -&gt; Stream&lt;'l, 'x * 'y&gt;
  val shift: timeout: Job&lt;_&gt; -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val delayEach: timeout: Job&lt;_&gt; -&gt; Stream&lt;#Lazy, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val afterEach: timeout: Job&lt;_&gt; -&gt; Stream&lt;#Lazy, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val beforeEach: timeout: Job&lt;_&gt; -&gt; Stream&lt;#Lazy, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val afterDateTimeOffsets: Stream&lt;#Lazy, DateTimeOffset&gt;
                         -&gt; Stream&lt;'l, DateTimeOffset&gt;
  val afterDateTimeOffset: DateTimeOffset -&gt; Stream&lt;'l, DateTimeOffset&gt;
  val afterTimeSpan: TimeSpan -&gt; Stream&lt;'l, unit&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.toSeq">toSeq</a>: Stream&lt;_, 'x&gt; -&gt; Job&lt;ResizeArray&lt;'x&gt;&gt;
  val values: Stream&lt;_, 'x&gt; -&gt; Alt&lt;'x&gt;
  val foldJob: ('s -&gt; 'x -&gt; #Job&lt;'s&gt;) -&gt; 's -&gt; Stream&lt;_, 'x&gt; -&gt; Job&lt;'s&gt;
  val foldFun: ('s -&gt; 'x -&gt; 's) -&gt; 's -&gt; Stream&lt;_, 'x&gt; -&gt; Job&lt;'s&gt;
  val foldFromJob: 's -&gt; ('s -&gt; 'x -&gt; #Job&lt;'s&gt;) -&gt; Stream&lt;_, 'x&gt; -&gt; Job&lt;'s&gt;
  val foldFromFun: 's -&gt; ('s -&gt; 'x -&gt; 's) -&gt; Stream&lt;_, 'x&gt; -&gt; Job&lt;'s&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.iterJob">iterJob</a>: ('x -&gt; #Job&lt;unit&gt;) -&gt; Stream&lt;_, 'x&gt; -&gt; Job&lt;unit&gt;
  val <a href="#def:val%20Hopac.Experimental.EagerSeq.iterFun">iterFun</a>: ('x -&gt; unit) -&gt; Stream&lt;_, 'x&gt; -&gt; Job&lt;unit&gt;
  val iter: Stream&lt;_, 'x&gt; -&gt; Job&lt;unit&gt;
  val count: Stream&lt;_, 'x&gt; -&gt; Job&lt;int64&gt;
  val head: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val tail: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val init: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val last: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'x&gt;
  val tails: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, Stream&lt;'l, 'x&gt;&gt;
  val inits: Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, Stream&lt;'l, 'x&gt;&gt;
  val tailsMapFun: (Stream&lt;'l, 'x&gt; -&gt; 'y) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'y&gt;
  val tailsMapFun: (Stream&lt;'l, 'x&gt; -&gt; 'y) -&gt; Stream&lt;'l, 'x&gt; -&gt; Stream&lt;'l, 'y&gt;
  val decon: Stream&lt;'l, 'x&gt; -&gt; Alt&lt;option&lt;'x * Stream&lt;'l, 'x&gt;&gt;&gt;
</span></code></pre>
<h2>Description</h2>
<pre><code class="fsharp">namespace Hopac.Experimental
</code></pre>
<div class="nested"><pre><code class="fsharp">type <a id="def:type Hopac.Experimental.Alts" href="#dec:type%20Hopac.Experimental.Alts">Alts</a>&lt;'x&gt;
</code></pre>
<div class="nested"><p> Represents a discrete event stream.</div>
<pre><code class="fsharp">module <a id="def:module Hopac.Experimental.Alts" href="#dec:module%20Hopac.Experimental.Alts">Alts</a> =
</code></pre>
<div class="nested"><p> Operations for programming with discrete event streams.</div>
<pre><code class="fsharp">module Alt =
</code></pre>
<div class="nested"><pre><code class="fsharp">module <a id="def:module Hopac.Experimental.Alt.Discrete" href="#dec:module%20Hopac.Experimental.Alt.Discrete">Discrete</a> =
</code></pre>
<div class="nested"><p> Operations for treating alternatives as a kind of discrete event sources allowing combinators for limited froms of event throttling, mapping and filtering.</p><p> The essence of this module is that a subset of alternatives forms a monad with plus where <code class="fsharp">once</code> is return, <code class="fsharp"><a href="#def:val%20Hopac.Experimental.Alt.Discrete.switchMap">switchMap</a></code> is bind, <code class="fsharp">never</code> is zero and <code class="fsharp"><a href="#def:val%20Hopac.Experimental.Alt.Discrete.merge">merge</a></code> is plus.  Note that many forms of alternatives, like <code class="fsharp">always</code>, do not combine in useful ways under this interpretation.</p><p> The limitation of technique is the one-shot or no-memory nature of the discrete event sources, which seems to make many useful combinators that can be expressed by choice streams, for example, impossible.<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.Alt.Discrete.merge" href="#dec:val%20Hopac.Experimental.Alt.Discrete.merge">merge</a>: Alt&lt;'x&gt; -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'x&gt;
</code></pre>
<div class="nested"><p> Given two event sources, creates an event source that produces events from both of the given event sources.</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.Alt.Discrete.switchMap" href="#dec:val%20Hopac.Experimental.Alt.Discrete.switchMap">switchMap</a>: ('x -&gt; Alt&lt;'y&gt;) -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'y&gt;
</code></pre>
<div class="nested"><p> Given an event source, <code class="fsharp">xE</code>, and a function that creates a new event source, <code class="fsharp">x2yE</code>, returns an event source that always produces events from the event source created by <code class="fsharp">x2yE</code> based on the latest value produced by <code class="fsharp">xE</code>.</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.Alt.Discrete.throttle" href="#dec:val%20Hopac.Experimental.Alt.Discrete.throttle">throttle</a>: timeout: Alt&lt;_&gt; -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'x&gt;
</code></pre>
<div class="nested"><p> Given a timeout and an event source, <code class="fsharp">xE</code>, creates an event source that produces only the events of <code class="fsharp">xE</code> after which there is a period of timeout without any events from <code class="fsharp">xE</code>.</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.Alt.Discrete.combineLatest" href="#dec:val%20Hopac.Experimental.Alt.Discrete.combineLatest">combineLatest</a>: Alt&lt;'x&gt; -&gt; Alt&lt;'y&gt; -&gt; Alt&lt;'x * 'y&gt;
</code></pre>
<div class="nested"><p> Given a pair of event sources, creates an event source that produces pairs of the latest events from the sources.</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.Alt.Discrete.choose" href="#dec:val%20Hopac.Experimental.Alt.Discrete.choose">choose</a>: ('x -&gt; option&lt;'y&gt;) -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'y&gt;
</code></pre>
<div class="nested"><p> Given a partial function and an event source, creates an event source that produces the partially mapped events.</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.Alt.Discrete.filter" href="#dec:val%20Hopac.Experimental.Alt.Discrete.filter">filter</a>: ('x -&gt; bool) -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'x&gt;
</code></pre>
<div class="nested"><p> Given a predicate and an event source, creates an event source that produces the events that satisfy the predicate.</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.Alt.Discrete.map" href="#dec:val%20Hopac.Experimental.Alt.Discrete.map">map</a>: ('x -&gt; 'y) -&gt; Alt&lt;'x&gt; -&gt; Alt&lt;'y&gt;
</code></pre>
<div class="nested"><p> Given a function and an event source, creates an event source that produces the mapped events.</div>
</div>
</div>
<pre><code class="fsharp">type <a id="def:type Hopac.Experimental.EagerSeq" href="#dec:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;
</code></pre>
<div class="nested"><p> A type of sequence where the producer is being run eagerly and the results it produces are memoized.</div>
<pre><code class="fsharp">module <a id="def:module Hopac.Experimental.EagerSeq" href="#dec:module%20Hopac.Experimental.EagerSeq">EagerSeq</a> =
</code></pre>
<div class="nested"><p> Operations on eager sequences.<pre><code class="fsharp">module <a id="def:module Hopac.Experimental.EagerSeq.Now" href="#dec:module%20Hopac.Experimental.EagerSeq.Now">Now</a> =
</code></pre>
<div class="nested"><p> Immediate or non-workflow operations on eager sequences.<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.Now.empty" href="#dec:val%20Hopac.Experimental.EagerSeq.Now.empty">empty</a>: unit -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;
</code></pre>
<div class="nested"><p> Creates an empty sequence.</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.Now.singleton" href="#dec:val%20Hopac.Experimental.EagerSeq.Now.singleton">singleton</a>: 'x -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;
</code></pre>
<div class="nested"><p> Creates a sequence containing the given element.</div>
</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.collectJob" href="#dec:val%20Hopac.Experimental.EagerSeq.collectJob">collectJob</a>: ('x -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.chooseFun" href="#dec:val%20Hopac.Experimental.EagerSeq.chooseFun">chooseFun</a>: ('x -&gt; option&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.chooseJob" href="#dec:val%20Hopac.Experimental.EagerSeq.chooseJob">chooseJob</a>: ('x -&gt; Job&lt;option&lt;'y&gt;&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.filterFun" href="#dec:val%20Hopac.Experimental.EagerSeq.filterFun">filterFun</a>: ('x -&gt; bool) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.generateFun" href="#dec:val%20Hopac.Experimental.EagerSeq.generateFun">generateFun</a>: (unit -&gt; option&lt;'x&gt;) -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.generateJob" href="#dec:val%20Hopac.Experimental.EagerSeq.generateJob">generateJob</a>: Job&lt;option&lt;'x&gt;&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.iterFun" href="#dec:val%20Hopac.Experimental.EagerSeq.iterFun">iterFun</a>: ('x -&gt; unit) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;unit&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.iterJob" href="#dec:val%20Hopac.Experimental.EagerSeq.iterJob">iterJob</a>: ('x -&gt; Job&lt;_&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;unit&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.mapFun" href="#dec:val%20Hopac.Experimental.EagerSeq.mapFun">mapFun</a>: ('x -&gt; 'y) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.mapJob" href="#dec:val%20Hopac.Experimental.EagerSeq.mapJob">mapJob</a>: ('x -&gt; Job&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'y&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.ofSeq" href="#dec:val%20Hopac.Experimental.EagerSeq.ofSeq">ofSeq</a>: seq&lt;'x&gt; -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.toSeq" href="#dec:val%20Hopac.Experimental.EagerSeq.toSeq">toSeq</a>: <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;ResizeArray&lt;'x&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.tryPickFun" href="#dec:val%20Hopac.Experimental.EagerSeq.tryPickFun">tryPickFun</a>: ('x -&gt; option&lt;'y&gt;) -&gt; <a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt; -&gt; Job&lt;option&lt;'y&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.unfoldFun" href="#dec:val%20Hopac.Experimental.EagerSeq.unfoldFun">unfoldFun</a>: ('s -&gt; option&lt;'x * 's&gt;) -&gt; 's -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
<pre><code class="fsharp">val <a id="def:val Hopac.Experimental.EagerSeq.unfoldJob" href="#dec:val%20Hopac.Experimental.EagerSeq.unfoldJob">unfoldJob</a>: ('s -&gt; Job&lt;option&lt;'x * 's&gt;&gt;) -&gt; 's -&gt; Job&lt;<a href="#def:type%20Hopac.Experimental.EagerSeq">EagerSeq</a>&lt;'x&gt;&gt;
</code></pre>
<div class="nested"><p> XXX</div>
</div>
</div>
</td></tr></table></body>
</html>
